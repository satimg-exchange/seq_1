<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <style>
    @import url('https://fonts.googleapis.com/css2?family=EB+Garamond&display=swap');

    :root {
      --pad: 20px;
      --border-color: #000;
      --max-content-width: 1000px;
      --thumbnail-size: 80px;
      --thumbnail-gap: 10px;
      --active-border-color: #1a73e8;
    }

    /* Reset */
    *, *::before, *::after {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      background: #fff;
      color: #000;
      font-family: 'EB Garamond', serif;
      font-size: 18px;
      line-height: 1.6;
      padding: 80px 60px 120px;
      max-width: 1200px;
      margin: auto;
      position: relative;
    }

    /* Simple top/bottom borders */
    body::before, body::after {
      content: "";
      position: fixed;
      left: 0;
      width: 100vw;
      height: 1px;
      background: var(--border-color);
      pointer-events: none;
      user-select: none;
      z-index: 9999;
    }
    body::before { top: 0; }
    body::after  { bottom: 0; }

    a.back-link {
      display: inline-block;
      font-family: 'EB Garamond', serif;
      text-decoration: none;
      color: #444;
      font-size: 0.9rem;
      margin-bottom: 40px;
      letter-spacing: 0.1em;
      text-transform: uppercase;
      user-select: none;
      cursor: pointer;
      transition: color 0.3s ease;
    }
    a.back-link:hover,
    a.back-link:focus-visible {
      color: #000;
      outline: none;
      text-decoration: underline;
    }

    h1 {
      font-weight: 700;
      font-size: 2.8rem;
      letter-spacing: 0.15em;
      text-align: center;
      margin-bottom: 60px;
      user-select: text;
    }

    /* DETAIL CONTAINER: flex‐column so gallery (big image + thumbnails) is first, info below */
    #detail-container {
      display: flex;
      flex-direction: column;
      gap: var(--pad);
    }

    /* ========== GALLERY ========== */
    .gallery-wrapper {
      width: 100%;
      max-width: var(--max-content-width);
      margin: 0 auto;
    }

    .main-image-container {
      position: relative;
      /* Let it shrink/grow to fit the image, not the other way around */
      display: flex;
      justify-content: center;
      align-items: center;
      /* Allow it to be at most the viewport size */
      max-width: 100vw;
      max-height: 100vh;
      /* If you still want rounded corners and a shadow: */
      border-radius: 14px;
      box-shadow:
        0 0 25px rgba(0 0 0 / 0.15),
        inset 0 0 60px rgba(0 0 0 / 0.08);

      /* No forced width/height, and no overflow:hidden */
      overflow: visible;
    }

    .main-image-container img.main-image {
      /* Let the image itself scale down so nothing is clipped */
      max-width: 100vw;
      max-height: 100vh;
      object-fit: contain;
      display: block;
      user-select: none;
      pointer-events: none;
    }

    .pip-photo {
      position: absolute;
      width: 150px;
      height: 150px;
      border-radius: 16px;
      object-fit: cover;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      border: 3px solid #fff;
      box-shadow: 0 6px 18px rgba(0 0 0 / 0.7);
      pointer-events: none;
      user-select: none;
      background: #111;
      mix-blend-mode: normal;
      transition: box-shadow 0.3s ease;
      will-change: transform;
    }
    .main-image-container:hover .pip-photo {
      box-shadow: 0 10px 40px rgba(0 0 0 / 0.85);
    }
    @media (max-width: 640px) {
      .pip-photo {
        width: 110px;
        height: 110px;
      }
    }

    /* ========== THUMBNAILS ROW ========== */
    .thumbnails-container {
      display: flex;
      justify-content: center;
      gap: var(--thumbnail-gap);
      margin-top: var(--thumbnail-gap);
      flex-wrap: wrap;
    }
    .thumbnail-item-wrapper {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 4px;
    }
    .thumbnail-item {
      width: var(--thumbnail-size);
      height: var(--thumbnail-size);
      object-fit: cover;
      border-radius: 4px;
      cursor: pointer;
      opacity: 0.6;
      transition: opacity 0.3s ease, border 0.3s ease;
      border: 2px solid transparent;
    }
    .thumbnail-item:hover {
      opacity: 1;
    }
    .thumbnail-item.active {
      opacity: 1;
      border: 2px solid var(--active-border-color);
    }
    .thumbnail-caption {
      font-size: 0.75rem;
      color: #666;
      text-align: center;
      max-width: 80px;
      word-wrap: break-word;
    }

    .image-label {
      font-size: 1rem;
      color: #666;
      font-style: italic;
      letter-spacing: 0.1em;
      margin-top: 14px;
      user-select: none;
      text-align: center;
      min-height: 1.5em;
      font-variant: small-caps;
      font-weight: 400;
      font-family: 'EB Garamond', serif;
    }

    /* ========== INFO SECTION (below the gallery) ========== */
    .info-container {
      display: grid;
      grid-template-columns: 400px 1fr;
      gap: var(--pad);
      max-width: var(--max-content-width);
      margin: 0 auto;
    }
    @media (max-width: 900px) {
      .info-container {
        display: flex;
        flex-direction: column;
      }
    }

    /* LEFT INFO (metadata) */
    .left-info h2 {
      font-size: 2.2rem;
      margin: 0 0 10px;
    }
    .left-info p {
      margin: 0.5em 0;
      line-height: 1.4;
    }
    .left-info .offset-location,
    .left-info .offset-coords,
    .left-info .offset-timestamp {
      font-size: 0.9rem;
      font-style: italic;
      color: #333;
      margin-top: 12px;
      margin-bottom: 12px;
    }
    .left-info .offset-description {
      font-size: 1rem;
      color: #111;
      margin-top: 0;
    }

    /* RIGHT INFO (formula + methodology) */
    .right-info {
      font-family: 'Times New Roman', serif;
      font-size: 1.3rem;
      color: #222;
      line-height: 1.5;
    }
    .right-info .formula {
      font-style: italic;
      font-size: 1.6rem;
      white-space: nowrap;
      margin-bottom: 1em;
    }
    .right-info hr {
      border: none;
      border-top: 1px solid #ccc;
      margin: 2em 0;
    }
    .right-info .methodology-title {
      font-weight: 700;
      font-style: normal;
      font-size: 1.4rem;
      margin-bottom: 1em;
    }
    .right-info .methodology-text p {
      margin-top: 0;
      margin-bottom: 1em;
    }
  </style>
</head>

<body>
  <a href="initial.html" class="back-link" tabindex="0">&larr; Back to Registry</a>


  <!-- DETAIL CONTAINER: gallery + thumbnails + label + info -->
  <div id="detail-container">
    <!-- Populated by JavaScript -->
  </div>

  <script>
    // 1) Load the JSON manifest (list of file paths)
    async function loadManifest() {
      try {
        const res = await fetch('assets/manifest.json');
        if (!res.ok) throw new Error('Failed to load manifest.json');
        return await res.json();
      } catch (e) {
        console.error(e);
        return null;
      }
    }

    // 2) Load the JSON metadata file (mapping folder → metadata object)
    async function loadMetadata() {
      try {
        const res = await fetch('assets/metadata.json');
        if (!res.ok) throw new Error('Failed to load metadata.json');
        return await res.json();
      } catch (e) {
        console.error(e);
        return {};
      }
    }

    // 3) Group file paths by folder name
    function groupByFolder(manifest) {
      const groups = {};
      manifest.forEach(path => {
        if (path.endsWith('.DS_Store') || path.endsWith('manifest.json')) return;
        const parts = path.split('/');
        if (parts.length < 3) return;
        const folder = parts[1];
        const filename = parts.slice(2).join('/');
        if (!groups[folder]) groups[folder] = [];
        groups[folder].push(filename);
      });
      return groups;
    }

    // 4) Build the detail‐page layout for one folder
    function createDetailPage(folder, files, metadata) {
      const container = document.getElementById('detail-container');

      //
      // ------- GALLERY WRAPPER (big image + PIP) -------
      //
      const galleryWrapper = document.createElement('div');
      galleryWrapper.className = 'gallery-wrapper';

      const galleryContainer = document.createElement('div');
      galleryContainer.className = 'main-image-container';
      galleryContainer.tabIndex = 0; // allow key navigation

      // Determine which images to cycle through:
      //   - originalMap (if `folder-map.png` exists)
      //   - followed by any “generated” map variants
      const originalPhoto = files.find(f => f === `${folder}.png`);
      const originalMap   = files.find(f => f === `${folder}-map.png`);
      // Generated maps are everything except the original photo and the original map
      const generatedMaps = files
        .filter(f => f !== originalPhoto && f !== originalMap)
        .sort(); // sort alphabetically so prompts align consistently

      // Build an array of captions: if there is an originalMap, index 0 is "Original Map Image",
      // then each generatedMaps corresponds to metadata.prompts[ index ].
      const labels = [];
      if (originalMap) {
        labels.push("Original Map Image");
      }
      // Add one label per generated map, using metadata.prompts in the same order
      metadata.prompts.forEach(promptText => {
        labels.push(promptText);
      });

      // Build cycleImages in the same order as labels
      const cycleImages = originalMap
        ? [originalMap, ...generatedMaps]
        : [...generatedMaps];

      let currentIndex = 0;
      const mainImg = document.createElement('img');
      mainImg.className = 'main-image';
      mainImg.src = cycleImages.length 
        ? `assets/${folder}/${cycleImages[0]}` 
        : '';
      mainImg.alt = labels[0] || '';
      galleryContainer.appendChild(mainImg);

      // If there’s an “original photo” (folder.png), overlay it in PIP
      if (originalPhoto) {
        const pip = document.createElement('img');
        pip.className = 'pip-photo';
        pip.src = `assets/${folder}/${originalPhoto}`;
        pip.alt = `${folder} original photo`;
        galleryContainer.appendChild(pip);
      }

      // Fade‐out/fade‐in when swapping the main image
      function updateImage(index) {
        mainImg.style.opacity = 0;
        setTimeout(() => {
          mainImg.src = `assets/${folder}/${cycleImages[index]}`;
          mainImg.alt = labels[index] || "";
          mainImg.style.opacity = 1;
        }, 400);
      }

      // 5) ========== THUMBNAILS ROW ==========
      const thumbnailsContainer = document.createElement('div');
      thumbnailsContainer.className = 'thumbnails-container';

      // Build one thumbnail <div> per cycleImages entry
      cycleImages.forEach((imgFilename, idx) => {
        const wrapper = document.createElement('div');
        wrapper.className = 'thumbnail-item-wrapper';

        const thumb = document.createElement('img');
        thumb.className = 'thumbnail-item';
        thumb.src = `assets/${folder}/${imgFilename}`;
        thumb.alt = labels[idx] || "";
        thumb.dataset.index = idx;

        // If this is the initial image, mark it active
        if (idx === 0) thumb.classList.add('active');

        // Clicking a thumbnail jumps to that index
        thumb.addEventListener('click', () => {
          if (currentIndex === idx) return;
          currentIndex = idx;
          updateImage(currentIndex);
          updateThumbnails(currentIndex);
          updateLabel(currentIndex);
        });
        wrapper.appendChild(thumb);

        // Caption below thumbnail
        const caption = document.createElement('div');
        caption.className = 'thumbnail-caption';
        caption.textContent = labels[idx] || "";
        wrapper.appendChild(caption);

        thumbnailsContainer.appendChild(wrapper);
      });

      // Highlighting logic for thumbnails
      function updateThumbnails(activeIndex) {
        const allThumbs = thumbnailsContainer.querySelectorAll('.thumbnail-item');
        allThumbs.forEach((thumb, i) => {
          if (i === activeIndex) {
            thumb.classList.add('active');
          } else {
            thumb.classList.remove('active');
          }
        });
      }

      // 6) Handle click or arrow‐key navigation on the big gallery
      galleryContainer.addEventListener('click', () => {
        if (!cycleImages.length) return;
        currentIndex = (currentIndex + 1) % cycleImages.length;
        updateImage(currentIndex);
        updateThumbnails(currentIndex);
        updateLabel(currentIndex);
      });
      galleryContainer.addEventListener('keydown', e => {
        if (!cycleImages.length) return;
        if (e.key === 'ArrowRight' || e.key === 'ArrowDown') {
          e.preventDefault();
          currentIndex = (currentIndex + 1) % cycleImages.length;
          updateImage(currentIndex);
          updateThumbnails(currentIndex);
          updateLabel(currentIndex);
        } else if (e.key === 'ArrowLeft' || e.key === 'ArrowUp') {
          e.preventDefault();
          currentIndex = (currentIndex - 1 + cycleImages.length) % cycleImages.length;
          updateImage(currentIndex);
          updateThumbnails(currentIndex);
          updateLabel(currentIndex);
        }
      });

      // Append big image + thumbnails to the wrapper, then to the container
      galleryWrapper.appendChild(galleryContainer);
      galleryWrapper.appendChild(thumbnailsContainer);
      container.appendChild(galleryWrapper);

      // ===== Image Label (below thumbnails) =====
      const labelDiv = document.createElement('div');
      labelDiv.className = 'image-label';
      container.appendChild(labelDiv);

      function updateLabel(index) {
        labelDiv.textContent = labels[index] || "";
      }
      // Initialize label
      updateLabel(currentIndex);

      //
      // ------- INFO CONTAINER (metadata + formula/methodology) -------
      //
      const infoContainer = document.createElement('div');
      infoContainer.className = 'info-container';

      // LEFT INFO: metadata (title, offsetBy, carbonOffset, vintage, location, coords, timestamp, description)
      const leftInfo = document.createElement('div');
      leftInfo.className = 'left-info';

      const h2 = document.createElement('h2');
      h2.textContent = metadata.title;
      leftInfo.appendChild(h2);

      // “Offset by:” (if present)
      if (metadata.offsetBy) {
        const offsetByP = document.createElement('p');
        offsetByP.innerHTML = `<strong>Offset by:</strong><br>${metadata.offsetBy}`;
        leftInfo.appendChild(offsetByP);
      }

      // “Carbon Offset:”
      if (metadata.carbonOffset) {
        const carbonOffsetP = document.createElement('p');
        carbonOffsetP.innerHTML = `<strong>Carbon Offset:</strong><br>${metadata.carbonOffset}`;
        leftInfo.appendChild(carbonOffsetP);
      }


      // Location
      const locationP = document.createElement('p');
      locationP.className = 'offset-location';
      locationP.textContent = `Location: ${metadata.location || 'Unknown'}`;
      leftInfo.appendChild(locationP);

      // Coordinates (if available)
      if (metadata.latitude != null && metadata.longitude != null) {
        const coordsP = document.createElement('p');
        coordsP.className = 'offset-coords';
        coordsP.innerHTML = `<strong>Coordinates:</strong> ${metadata.latitude.toFixed(6)}, ${metadata.longitude.toFixed(6)}`;
        leftInfo.appendChild(coordsP);
      }

      // Timestamp (if available)
      if (metadata.timestamp) {
        const tsP = document.createElement('p');
        tsP.className = 'offset-timestamp';
        tsP.innerHTML = `<strong>Timestamp:</strong> ${metadata.timestamp}`;
        leftInfo.appendChild(tsP);
      }

      // Description
      const descP = document.createElement('p');
      descP.className = 'offset-description';
      descP.textContent = metadata.description;
      leftInfo.appendChild(descP);

      infoContainer.appendChild(leftInfo);

      // RIGHT INFO: formula + methodology
      const rightInfo = document.createElement('div');
      rightInfo.className = 'right-info';

      if (metadata.formula) {
        const formulaP = document.createElement('p');
        formulaP.className = 'formula';
        formulaP.textContent = metadata.formula;
        rightInfo.appendChild(formulaP);
      }

      // Horizontal rule between formula and methodology
      rightInfo.appendChild(document.createElement('hr'));

      if (metadata.methodologyTitle) {
        const mTitle = document.createElement('h4');
        mTitle.className = 'methodology-title';
        mTitle.textContent = metadata.methodologyTitle;
        rightInfo.appendChild(mTitle);
      }

      if (metadata.methodologyText) {
        const textWrapper = document.createElement('div');
        textWrapper.className = 'methodology-text';
        metadata.methodologyText.split('\n\n').forEach(paragraph => {
          const p = document.createElement('p');
          p.innerHTML = paragraph.replace(/\n/g, '<br />');
          textWrapper.appendChild(p);
        });
        rightInfo.appendChild(textWrapper);
      }

      infoContainer.appendChild(rightInfo);
      container.appendChild(infoContainer);
    }

    // 5) Initialize: read “?case=folder” from URL, then fetch JSONs, group files, and build page
    async function init() {
      const folder = new URLSearchParams(window.location.search).get('case');
      const container = document.getElementById('detail-container');

      if (!folder) {
        container.textContent = 'No case selected.';
        return;
      }

      // Fetch manifest.json and metadata.json simultaneously
      const [manifest, metadataMap] = await Promise.all([
        loadManifest(),
        loadMetadata()
      ]);
      if (!manifest) {
        container.textContent = 'Failed to load manifest.';
        return;
      }

      const grouped = groupByFolder(manifest);
      if (!grouped[folder]) {
        container.textContent = 'Case not found.';
        return;
      }

      // Look up metadata for this folder (or fall back to defaults)
      let meta = metadataMap[folder] || {
        title: folder,
        offset: "",            // (legacy)
        offsetBy: "",
        carbonOffset: "",
        vintage: "",
        location: "Unknown",
        latitude: null,
        longitude: null,
        timestamp: null,
        description: "No description available.",
        formula: "",
        methodologyTitle: "",
        methodologyText: "",
        prompts: []
      };

      createDetailPage(folder, grouped[folder], meta);
    }

    init();
  </script>
</body>
</html>
